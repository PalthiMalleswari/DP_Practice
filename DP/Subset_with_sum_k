# Given an array arr of n integers and an integer K, count the number of subsets of the given array that have a sum equal to K. Return the result modulo (109 + 7).

Input: arr = [2, 3, 5, 16, 8, 10], K = 10
Output: 3
Explanation: The subsets are [2, 8], [10], and [2, 3, 5].

#================== Brute Force ===================

def count_subset(ind,target):
    if target == 0:
        return 1
    if ind == 0 :
      ans = 1 if (arr[ind] == target) else 0 
      return ans
    not_take = count_subset(ind-1,target)
    take = 0
    if target >= arr[ind]:
      take = count_subset(ind-1,target-arr[ind])
    return take + not_take

n = len(arr)
count_subset(n-1,k)


Time Complexity: O(2^N)
Space Complexity: stack space

#=====================   DP(Memorization)  ============================

dp = [ [ -1 for j in range(target+1)] for i in range(N) ]

def count_subset(ind,target):
    if target == 0:
        dp[ind][0] = 1
        return dp[ind][0]

    if ind == 0 :
      ans = 1 if (arr[ind] == target) else 0 
      dp[ind][target] = ans
      return dp[ind][target]

    if dp[ind][target] != -1:
        return dp[ind][target]

    not_take = count_subset(ind-1,target)
    take = 0
    if target >= arr[ind]:
      take = count_subset(ind-1,target-arr[ind])
    dp[ind][target] = take + not_take

    return dp[ind][target]

Time Complexity: O(N*K)
Space Complexity: O(N*K) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*K)).

#========================  DP(Tabulation) ==============================

n = len(num)
    
dp = [[0] * (k + 1) for _ in range(n)]

for i in range(n):
    dp[i][0] = 1

if num[0] <= k:
    dp[0][num[0]] = 1

for ind in range(1, n):
    for target in range(1, k + 1):
       
        notTaken = dp[ind - 1][target]
    
        taken = 0
        if num[ind] <= target:
            taken = dp[ind - 1][target - num[ind]]
        
      
        dp[ind][target] = notTaken + taken

return dp[n - 1][k]

Time Complexity: O(N*K)
Space Complexity: O(N*K)

#========================  DP(Tabulation) ==============================

n = len(num)

prev = [0 for i in range(k + 1)]

prev[0] = 1


if num[0] <= k:
    prev[num[0]] = 1

for ind in range(1, n):

    cur = [0 for i in range(k + 1)]
    cur[0] = 1
    
    for target in range(1, k + 1):

        notTaken = prev[target]

        taken = 0
        if num[ind] <= target:
            taken = prev[target - num[ind]]

        cur[target] = notTaken + taken

    prev = cur

return prev[k]

Time Complexity: O(N*K)

Reason: There are two nested loops

Space Complexity: O(K)

Reason: We are using an external array of size ‘K+1’ to store only one row.


